// ==============================
// Rob√¥ Sumo ‚Äî Vers√£o Simplificada
// ==============================

// ---- Pinos dos motores ----
int motorA_frente = 9;
int motorA_tras   = 6;
int motorB_frente = 5;
int motorB_tras   = 3;

// // ---- Sensor ultrass√¥nico ----
// int trig = 10;
// int echo = 11;

// // ---- Sensores de reflet√¢ncia ----
// int sensorE = A0;   // Esquerda
// int sensorD = A1;   // Direita

// ---- Bot√£o de in√≠cio ----
int botao = 12;

// ---- Par√¢metros ----
int limite_reflex = 600;     // Limite da linha branca
int distancia_ataque = 10;   // Dist√¢ncia para atacar (cm)
int distancia_max = 120;     // Limite m√°ximo de leitura
int vel_max = 255;
int vel_min = 120;
int vel_re = 180;

bool combateAtivo = false;   // Indica se o combate come√ßou

// ==============================
// Fun√ß√µes b√°sicas de movimento
// ==============================

void parar() {
  analogWrite(motorA_frente, 0);
  analogWrite(motorA_tras, 0);
  analogWrite(motorB_frente, 0);
  analogWrite(motorB_tras, 0);
}

void frente(int vel) {
  analogWrite(motorA_frente, vel);
  analogWrite(motorA_tras, 0);
  analogWrite(motorB_frente, vel);
  analogWrite(motorB_tras, 0);
}

void re(int vel) {
  analogWrite(motorA_frente, 0);
  analogWrite(motorA_tras, vel);
  analogWrite(motorB_frente, 0);
  analogWrite(motorB_tras, vel);
}

void girarDireita(int vel) {
  analogWrite(motorA_frente, vel);
  analogWrite(motorA_tras, 0);
  analogWrite(motorB_frente, 0);
  analogWrite(motorB_tras, vel);
}

void girarEsquerda(int vel) {
  analogWrite(motorA_frente, 0);
  analogWrite(motorA_tras, vel);
  analogWrite(motorB_frente, vel);
  analogWrite(motorB_tras, 0);
}

// ==============================
// Leitura dos sensores
// ==============================

// Mede dist√¢ncia do inimigo
// int lerDistancia() {
//   digitalWrite(trig, LOW);
//   delayMicroseconds(2);
//   digitalWrite(trig, HIGH);
//   delayMicroseconds(10);
//   digitalWrite(trig, LOW);

//   long duracao = pulseIn(echo, HIGH, 30000);
//   if (duracao == 0) return 0;

//   int distancia = duracao * 0.034 / 2;
//   return distancia;
// }

// // Faz m√©dia simples de leitura da reflet√¢ncia
// int lerRefletancia(int pino) {
//   long soma = 0;
//   for (int i = 0; i < 5; i++) {
//     soma += analogRead(pino);
//     delay(2);
//   }
//   return soma / 5;
// }

// ==============================
// Comportamento do rob√¥
// ==============================

void comportamento() {
  frente(vel_max);
  delay(3000);
  parar();
}

// ==============================
// Setup
// ==============================
void setup() {
  Serial.begin(9600);

  pinMode(botao, INPUT_PULLUP);
  // pinMode(trig, OUTPUT);
  // pinMode(echo, INPUT);

  // pinMode(sensorE, INPUT);
  // pinMode(sensorD, INPUT);

  pinMode(motorA_frente, OUTPUT);
  pinMode(motorA_tras, OUTPUT);
  pinMode(motorB_frente, OUTPUT);
  pinMode(motorB_tras, OUTPUT);

  parar();
  Serial.println("‚úÖ Pronto! Aperte o bot√£o para come√ßar...");
}

// ==============================
// Loop principal
// ==============================
void loop() {
  // Espera o bot√£o
  if (!combateAtivo && digitalRead(botao) == LOW) {
    Serial.println("üïí Bot√£o pressionado! Iniciando em 3 segundos...");
    parar();

    for (int i = 3; i > 0; i--) {
      Serial.print("Come√ßando em ");
      Serial.println(i);
      delay(1000);
    }

    Serial.println("üöÄ Combate iniciado!");
    combateAtivo = true;
  }

  // Se estiver em combate, executa comportamento
  if (combateAtivo) comportamento();
  else parar();

  delay(50);
}
